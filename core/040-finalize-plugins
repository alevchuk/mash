#!/usr/bin/env Rscript

library(rjson)

load.biostirngs = function() { # Loaded after checking parameters
  library(Biostrings) 
}


initial.options <- commandArgs()
file.arg.name <- "--file="

script.path <- sub(file.arg.name, "", 
  initial.options[grep(file.arg.name, initial.options)])

script.path.list <- strsplit(script.path, '/')[[1]]
script.dir.list  <- script.path.list[1:(length(script.path.list)-1)]

software.dir  <- paste(c(script.dir.list, '..'), sep='/', collapse='/')
script.name <- script.path.list[[length(script.path.list)]]



script.args <- commandArgs(trailingOnly=T)

if(length(script.args) != 1) {
       cat(paste(
         paste("Usage:", script.name, "<webdata>\n"),
         "Required Options",
         "  <webdata>      directory with files produced by the analyzer",
         "",
         sep="\n"))
       quit()
}

dir.path.webdata  <- sub("/$", "", script.args[[1]])
dir.name.webdata  <- tail(strsplit(dir.path.webdata, "/")[[1]], 1)

dir.plugins  <- paste(software.dir, "plugins", sep='/')


file.msa     <- paste(dir.path.webdata, 'msa.json', sep='/')
msa          <- fromJSON(readLines(file.msa))

file.headers <- paste(dir.path.webdata, 'headers.json', sep='/')
headers      <- fromJSON(readLines(file.headers))

file.menu    <- paste(dir.path.webdata, 'menu.json', sep='/')


# Read the Menu file
menu_data    <- fromJSON(readLines(file.menu))


########################################################
## Every character will be surrounded by <b>          ##
########################################################
# Don't worry, we can afford this
# the benifit is control over HTML
#  * Standardized spacing around the charcters
########################################################
nice_html_spacing <- function(x) {paste('<b>', x, '</b>', sep="")}
nice_html_spacing_of_string <- function(x) {
  y <- lapply(strsplit(x, "", fixed=T)[[1]], nice_html_spacing)
  paste(y, sep="", collapse="")
}

########################################################
## Generate HTML from JSON files generated by plugins ##
########################################################
colorizeWithPlugin <- function (msa, plugin_data) {

  characters <- lapply(msa, function(x){strsplit(x, "", fixed=T)[[1]]})

  # Surround every character with <b> - this is for CSS viewing eligance
  characters <- lapply(characters, nice_html_spacing)

  place_one_tag <- function(sequence_id, pos, tag) {
    letter <- characters[[sequence_id]][[pos]]
    colored_letter <- paste("<", tag, ">", letter, "</", tag, ">", sep="")

    #if (substr(letter, 1, 1) == "<") {
    #  # Remove previous tag(s)
    #  letter <- gsub("<.*?>", "", letter)
    # 
    #  # Indicate a collision 
    #  colored_letter <- paste("<error>", letter, "</error>", sep="") 
    #}

    characters[[sequence_id]][[pos]] <<- colored_letter
  }

  for (color in plugin_data$colors) {
    tag = color$color
    lapply(color$positions, function(x){place_one_tag(x[1], x[2], tag)})
  }



  return(lapply(characters, function(x){paste(x, sep="", collapse="")}))
}


####################################
## Viewing of MSAs in HTML Format ##
####################################
## Original Author: Thomas Girke
## Viewing large alignments in a web browser can be very efficient.
## The following example outputs an HTML formatted alignment with
## consensus line.
StringSet2html <- function(start=1, ruler_step=20, end=length(msa[[1]]),
                           msa, ...) {
        if(class(msa)=="AAStringSet")
          msa <- AAStringSet(msa, start=start, end=end)
        if(class(msa)=="DNAStringSet")
          msa <- DNAStringSet(msa, start=start, end=end)
        msavec <- sapply(msa, toString)

        offset <- (ruler_step-1)-nchar(nchar(msavec[1]))
        # ruler <- paste(paste(paste(paste(rep(" ", offset), collapse=""),
        #   format(seq(0, 
        #     nchar(msavec[1]), by=ruler_step)[-1]
        #   )), collapse=""), collapse="")
        n <- nchar(msavec[1])
        ruler <- rep(" ", n)
        ruler[seq(1, n, by=ruler_step)[-1] - 1] <- 
          lapply(seq(1, n, by=ruler_step)[-1] - 1, function(x){
          paste(" ", "<span class='ruler-mark'>", x, "</span>", sep="")
        })
        ruler <- lapply(ruler, nice_html_spacing)
        ruler <- paste(ruler,  collapse="")
        ruler_line <- rep("~", n)
        ruler_line[seq(1, n, by=ruler_step)[-1] - 1] <- "+"
        ruler_line <- lapply(ruler_line, nice_html_spacing)
        ruler_line <- paste(ruler_line,  collapse="")

        consensus <- consensusString(msavec, ambiguityMap=".", ...)
        consensus <- nice_html_spacing_of_string(consensus)
        
        msavec_html <- 
          paste(msavec_html, rowSums(as.matrix(msa) != "-"), sep="  ")

        msavec <- paste(
          format(c("", "", names(msa), "Consensus"), justify="left"),
              c(ruler, ruler_line, msavec_html, consensus), sep="  ")


        msavec <- sapply(msavec, 
          function(i){c(paste("<div class=\"s\">", i, "</div>", collapse=""))})

        return(msavec)
}


# Get plugin list from menu
# TODO:Check that at least 1 plugin exists
for (name.plugin in menu_data$plugins) {

  file.plugin_data <- paste(dir.path.webdata, paste(name.plugin, "json", sep="."), sep = "/", collapse="")
  file.plugin_html <- paste(dir.path.webdata, paste(name.plugin, "html", sep="."), sep = "/", collapse="")
  plugin_data      <- fromJSON(readLines(file.plugin_data))
  
  
  msavec_html <- colorizeWithPlugin(msa, plugin_data)
  
  load.biostirngs()
  
  biostrings_msa = AAStringSet(msa)
  names(biostrings_msa) = headers
  
  html <- StringSet2html(msa=biostrings_msa, ruler_step=20, threshold=0.9)
  writeLines(html, file.plugin_html)
}
