#!/usr/bin/env Rscript

library(rjson)

load.biostirngs = function() { # Loaded after checking parameters
  library(Biostrings) 
}


initial.options <- commandArgs()
file.arg.name <- "--file="

script.path <- sub(file.arg.name, "", 
  initial.options[grep(file.arg.name, initial.options)])

script.path.list <- strsplit(script.path, '/')[[1]]
script.dir.list  <- script.path.list[1:(length(script.path.list)-1)]

script.dir  <- paste(c(script.dir.list, '..'), sep='/', collapse='/')
script.name <- script.path.list[[length(script.path.list)]]



script.args <- commandArgs(trailingOnly=T)

if(length(script.args) != 1) {
       cat(paste(
         paste("Usage:", script.name, "<webdata>\n"),
         "Required Options",
         "  <webdata>      directory with files produced by the analyzer",
         "",
         sep="\n"))
       quit()
}

dir.webdata  <- sub("/$", "", script.args[[1]])

file.msa     <- paste(dir.webdata, 'msa.json', sep='/')
msa          <- fromJSON(readLines(file.msa))

file.headers <- paste(dir.webdata, 'headers.json', sep='/')
headers      <- fromJSON(readLines(file.headers))

file.menu    <- paste(dir.webdata, 'menu.json', sep='/')
headers      <- fromJSON(readLines(file.headers))


# TODO: get plugin list from menu

### TMP
file.data.plugin1 = paste(dir.webdata, "/gblocks_in_r.coloring-scorer.json", sep = "", collapse="")
file.html.plugin1 = paste(dir.webdata, "/gblocks_in_r.coloring-scorer.html", sep = "", collapse="")
plugin1_data = fromJSON(readLines(file.data.plugin1))

########################################################
## Every character will be surrounded by <b>          ##
########################################################
# Don't worry, we can afford this
# the benifit is control over HTML
#  * Standardized spacing around the charcters
########################################################
nice_html_spacing <- function(x) {paste('<b>', x, '</b>', sep="")}
nice_html_spacing_of_string <- function(x) {
  y <- lapply(strsplit(x, "", fixed=T)[[1]], nice_html_spacing)
  paste(y, sep="", collapse="")
}

########################################################
## Generate HTML from JSON files generated by plugins ##
########################################################
colorizeWithPlugin <- function (msa, plugin_data) {

  characters <- lapply(msa, function(x){strsplit(x, "", fixed=T)[[1]]})

  # Surround every character with <b> - this is for CSS viewing eligance
  characters <- lapply(characters, nice_html_spacing)

  place_one_tag <- function(sequence_id, pos, tag) {
    letter <- characters[[sequence_id]][[pos]]
    colored_letter <- paste("<", tag, ">", letter, "</", tag, ">", sep="")

    #if (substr(letter, 1, 1) == "<") {
    #  # Remove previous tag(s)
    #  letter <- gsub("<.*?>", "", letter)
    # 
    #  # Indicate a collision 
    #  colored_letter <- paste("<error>", letter, "</error>", sep="") 
    #}

    characters[[sequence_id]][[pos]] <<- colored_letter
  }

  for (color in plugin_data$colors) {
    tag = color$color
    lapply(color$positions, function(x){place_one_tag(x[1], x[2], tag)})
  }



  return(lapply(characters, function(x){paste(x, sep="", collapse="")}))
}

msavec_html <- colorizeWithPlugin(msa, plugin1_data)

####################################
## Viewing of MSAs in HTML Format ##
####################################
## Original Author: Thomas Girke
## Viewing large alignments in a web browser can be very efficient.
## The following example outputs an HTML formatted alignment with
## consensus line.
StringSet2html <- function(start=1, ruller_step=20, end=length(msa[[1]]),
                           msa, ...) {
        if(class(msa)=="AAStringSet")
          msa <- AAStringSet(msa, start=start, end=end)
        if(class(msa)=="DNAStringSet")
          msa <- DNAStringSet(msa, start=start, end=end)
        msavec <- sapply(msa, toString)

        offset <- (ruller_step-1)-nchar(nchar(msavec[1]))
        # ruller <- paste(paste(paste(paste(rep(" ", offset), collapse=""),
        #   format(seq(0, 
        #     nchar(msavec[1]), by=ruller_step)[-1]
        #   )), collapse=""), collapse="")
        n <- nchar(msavec[1])
        ruller <- rep(" ", n)
        ruller[seq(1, n, by=ruller_step)[-1] - 1] <- 
          lapply(seq(1, n, by=ruller_step)[-1] - 1, function(x){
          paste(" ", "<span class='ruller-mark'>", x, "</span>", sep="")
        })
        ruller <- lapply(ruller, nice_html_spacing)
        ruller <- paste(ruller,  collapse="")
        consensus <- consensusString(msavec, ambiguityMap=".", ...)
        consensus <- nice_html_spacing_of_string(consensus)
        
        msavec <- paste(msavec, rowSums(as.matrix(msa) != "-"), sep="  ")
        msavec <- paste(format(c("", names(msa), "Consensus"), justify="left"),
          c(ruller, msavec_html, consensus), sep="  ")


        msavec <- sapply(msavec, 
          function(i){c(paste("<div class=\"s\">", i, "</div>", collapse=""))})

        return(msavec)
}

load.biostirngs()

biostrings_msa = AAStringSet(msa)
names(biostrings_msa) = headers

html <- StringSet2html(msa=biostrings_msa, ruller_step=20, threshold=0.7)
writeLines(html, file.html.plugin1)
